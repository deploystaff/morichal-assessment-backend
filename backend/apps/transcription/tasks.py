"""
Celery tasks for transcript analysis and audio transcription.
"""

import json
from celery import shared_task
from django.conf import settings
from django.utils import timezone
from django.core.mail import send_mail


@shared_task(bind=True, max_retries=3)
def transcribe_audio_task(self, meeting_id: str, audio_data: bytes, filename: str, api_key: str = None):
    """
    Async audio transcription using OpenAI Whisper.
    """
    from apps.meetings.models import Meeting
    import openai

    try:
        meeting = Meeting.objects.get(id=meeting_id)
        effective_api_key = api_key or settings.OPENAI_API_KEY

        if not effective_api_key:
            raise ValueError('OpenAI API key not configured')

        client = openai.OpenAI(api_key=effective_api_key)

        # Create temp file for transcription
        import tempfile
        import os

        # Determine file extension
        ext = os.path.splitext(filename)[1] or '.mp3'

        with tempfile.NamedTemporaryFile(suffix=ext, delete=False) as f:
            f.write(audio_data)
            temp_path = f.name

        try:
            with open(temp_path, 'rb') as audio_file:
                transcription = client.audio.transcriptions.create(
                    model='whisper-1',
                    file=audio_file,
                    response_format='verbose_json'
                )

            meeting.transcript_text = transcription.text
            meeting.transcript_filename = filename
            meeting.transcript_uploaded_at = timezone.now()
            meeting.transcript_source = 'whisper'
            meeting.transcript_duration = getattr(transcription, 'duration', None)
            meeting.transcript_language = getattr(transcription, 'language', None)
            meeting.save()

            return {
                'success': True,
                'meeting_id': str(meeting_id),
                'text_length': len(transcription.text),
                'duration': getattr(transcription, 'duration', None),
                'language': getattr(transcription, 'language', None),
            }

        finally:
            os.unlink(temp_path)

    except Exception as e:
        self.retry(exc=e, countdown=60)


def send_analysis_email(meeting, summary: str, action_items: list):
    """
    Send meeting analysis email to client contacts.
    """
    if not settings.EMAIL_HOST_USER:
        # Email not configured, skip silently
        return

    subject = f"Meeting Analysis: {meeting.title}"

    # Build action items text
    action_items_text = ""
    if action_items:
        action_items_text = "\n".join([
            f"  - {item.get('title', 'Untitled')} (Assignee: {item.get('assignee', 'TBD')}, Priority: {item.get('priority', 'medium')})"
            for item in action_items
        ])
    else:
        action_items_text = "  No action items identified."

    message = f"""Meeting Analysis Complete

Meeting: {meeting.title}
Date: {meeting.date}

SUMMARY
-------
{summary or 'No summary generated.'}

ACTION ITEMS
------------
{action_items_text}

---
This analysis was generated by MorichalAI.
View full details at: https://morichalai-assessment.netlify.app
"""

    # Get recipient emails from meeting attendees
    recipient_emails = []
    if meeting.attendees:
        # Filter for valid email addresses
        for attendee in meeting.attendees:
            if '@' in str(attendee):
                recipient_emails.append(attendee)

    if recipient_emails:
        try:
            send_mail(
                subject=subject,
                message=message,
                from_email=settings.DEFAULT_FROM_EMAIL,
                recipient_list=recipient_emails,
                fail_silently=True,
            )
        except Exception:
            pass  # Don't fail analysis if email fails


def run_transcript_analysis(meeting_id: str):
    """
    Synchronous transcript analysis using Claude.
    Extracts answers, business rules, decisions, action items, and generates summary.
    """
    from apps.meetings.models import Meeting, MeetingSummary
    from apps.questions.models import Question
    from apps.suggestions.models import AISuggestion
    from apps.settings_app.models import ClientSettings
    import anthropic

    meeting = Meeting.objects.select_related('client').get(id=meeting_id)

    if not meeting.transcript_text:
        return {'error': 'No transcript available'}

    # Debug: check if meeting has client
    if not meeting.client:
        return {'error': f'Meeting {meeting_id} has no client associated. Cannot retrieve API key.'}

    # Get API key: first from client settings, then fall back to environment variable
    api_key = None
    try:
        client_settings = ClientSettings.objects.get(client=meeting.client)
        api_key = client_settings.anthropic_api_key
        if api_key:
            # Strip whitespace that might have been added
            api_key = api_key.strip()
    except ClientSettings.DoesNotExist:
        pass

    if not api_key:
        api_key = settings.ANTHROPIC_API_KEY
        if api_key:
            api_key = api_key.strip()

    if not api_key:
        return {'error': 'Anthropic API key not configured. Please add your API key in Settings.'}

    # Validate API key format
    if not api_key.startswith('sk-ant-'):
        return {'error': f'Invalid API key format. Key should start with sk-ant-. Got: {api_key[:10]}...'}

    # Get pending questions for context
    pending_questions = list(Question.objects.filter(
        client=meeting.client,
        status='pending'
    ).values('id', 'question_code', 'question', 'priority'))

    # Build the enhanced analysis prompt
    system_context = """You are an AI assistant specialized in analyzing meeting transcripts for MorichalAI,
a trade and supply chain platform. Your job is to:

1. Find answers to pending questions from the transcript
2. Discover business rules mentioned in the conversation
3. Identify decisions that were made
4. Extract action items with assignees and priorities
5. Generate a concise meeting summary (2-3 paragraphs)
6. Extract 3-5 key points from the meeting

Return your analysis as JSON with the following structure:
{
    "answers": [{"question_id": "uuid", "answer": "detailed answer text", "confidence": 0.0-1.0, "source_quote": "exact quote from transcript"}],
    "businessRules": [{"title": "short title", "description": "detailed description", "category": "category", "confidence": 0.0-1.0}],
    "decisions": [{"title": "short title", "description": "what was decided", "confidence": 0.0-1.0}],
    "actionItems": [{"title": "action title", "description": "detailed description", "assignee": "person name", "priority": "high|medium|low", "confidence": 0.0-1.0}],
    "summary": "2-3 paragraph summary of the meeting covering main topics discussed, key outcomes, and next steps",
    "keyPoints": ["Key point 1", "Key point 2", "Key point 3"]
}

Important: Only include answers where you found clear information in the transcript. Use the exact question_id provided."""

    questions_context = ""
    if pending_questions:
        questions_context = "\n\nPending questions to look for answers (use exact question_id in your response):\n"
        for q in pending_questions:
            questions_context += f"- [ID: {q['id']}] [{q['question_code']}] {q['question']}\n"

    prompt = f"""Analyze this meeting transcript and extract insights.

TRANSCRIPT:
{meeting.transcript_text[:15000]}

{questions_context}

Return ONLY valid JSON, no other text."""

    # Call Claude API
    client = anthropic.Anthropic(api_key=api_key)

    message = client.messages.create(
        model='claude-sonnet-4-20250514',
        max_tokens=4096,
        system=system_context,
        messages=[{'role': 'user', 'content': prompt}]
    )

    # Parse the response
    response_text = message.content[0].text

    # Try to extract JSON from the response
    try:
        start = response_text.find('{')
        end = response_text.rfind('}') + 1
        if start >= 0 and end > start:
            analysis = json.loads(response_text[start:end])
        else:
            analysis = {'answers': [], 'businessRules': [], 'decisions': [], 'actionItems': [], 'summary': '', 'keyPoints': []}
    except json.JSONDecodeError:
        analysis = {'answers': [], 'businessRules': [], 'decisions': [], 'actionItems': [], 'summary': '', 'keyPoints': []}

    # Track results
    answers_applied = 0
    suggestions_created = 0

    # AUTO-APPLY ANSWERS directly to Questions (no approval needed)
    for item in analysis.get('answers', []):
        question_id = item.get('question_id')
        if question_id:
            try:
                question = Question.objects.get(id=question_id, client=meeting.client)
                # Directly update the question
                question.answer = item.get('answer', '')
                question.answered_by = 'AI Analysis'
                question.answered_date = timezone.now().date()
                question.status = 'answered'
                question.save()
                answers_applied += 1
            except Question.DoesNotExist:
                pass

    # Process business rules (still create suggestions for review)
    for item in analysis.get('businessRules', []):
        AISuggestion.objects.create(
            meeting=meeting,
            client=meeting.client,
            suggestion_type='business_rule',
            suggested_content=item,
            confidence=item.get('confidence', 0.8),
        )
        suggestions_created += 1

    # Process decisions (still create suggestions for review)
    for item in analysis.get('decisions', []):
        AISuggestion.objects.create(
            meeting=meeting,
            client=meeting.client,
            suggestion_type='decision',
            suggested_content=item,
            confidence=item.get('confidence', 0.8),
        )
        suggestions_created += 1

    # Process action items (still create suggestions for review)
    for item in analysis.get('actionItems', []):
        AISuggestion.objects.create(
            meeting=meeting,
            client=meeting.client,
            suggestion_type='action_item',
            suggested_content=item,
            confidence=item.get('confidence', 0.8),
        )
        suggestions_created += 1

    # CREATE MEETING SUMMARY
    summary_text = analysis.get('summary', '')
    key_points = analysis.get('keyPoints', [])

    if summary_text:
        MeetingSummary.objects.update_or_create(
            meeting=meeting,
            defaults={
                'client': meeting.client,
                'content': summary_text,
                'key_points': key_points,
                'generated_by': 'ai',
            }
        )

    # SEND EMAIL to client with summary and action items
    send_analysis_email(
        meeting=meeting,
        summary=summary_text,
        action_items=analysis.get('actionItems', [])
    )

    return {
        'success': True,
        'meeting_id': str(meeting_id),
        'answers_applied': answers_applied,
        'suggestions_created': suggestions_created,
        'summary_generated': bool(summary_text),
    }


@shared_task(bind=True, max_retries=2)
def analyze_transcript_task(self, meeting_id: str):
    """
    Async wrapper for transcript analysis (uses Celery if available).
    """
    try:
        return run_transcript_analysis(meeting_id)
    except Exception as e:
        self.retry(exc=e, countdown=120)
